import React, { useEffect, useRef, useState } from 'react';
import * as THREE from 'three';
import './Globe.css';

const worldMap = ["000000000000000000000000000000000000000000000000000000001111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000000000000111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000000000001111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000000000001111111110111111111111111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000000000000111111000011111111111111111111110000000000000000000000000000000000000000000000000000011111111100000000000000000000000000000000000000000000000000", "000000000000000000000000000000001110000000000000000000000000000011111111111111111110000000000000000000000000000000000000000000000000111111111111100000000000000000000000000000000000000000000000000", "000000000000000000000000000000111111101110000000111111100000000011111111111111110000000000000000000000000000000000000000000011100111111111111111111100111100000011000000000000000000000000000000000", "000000000000001111100000000000111111111110011100111111111000000001111111111111110000000000000000000000000000000000000000000011111111111111111111111111111111110011111111110000000000000000000000000", "000000001111111111110000111110000111111110011100110111111000000001111111111111110000000000000000000001111111110000000000110011111111111111111111111111111111111111111111111111110011100000000000000", "000001111111111111111111111111111111111100111111110001111100001111111111111111100000000000000000000111111111111110001111111101111111111111111111111111111111111111111111111111111111111111000000000", "000111111111111111111111111111111111111111111111100001111100000111111111100000000000000000000000001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000", "001111111111111111111111111111111111111111111110000111111100000111111111000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000", "001111111111111111111111111111111111111111111000000111111000000111111000000000000000000000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110111000", "111111111111111111111111111111111111111111110000010011110000000111111000000000000000000000000001111111011111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000", "111111111111111111111111111111111111111110000000111100110000000011110000000000000000000000000011111111011111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000", "111111111111111111111111111111111111111000000011111100110000000001100000000000000000000000000011111111011111111111111111111111111111111111111111111111111111111111111111111111111100011111100000000", "111110100000111111111111111111111111110000000011111111110000000000000000000000000000000000000011111111001111111111111111111111111111111111111111111111111111111111111111111111111100111101000000000", "011000000000011111111111111111111111111000000011111111110000000000000000000000000000000000000000011110111111111111111111111111111111111111111111111111111111111111111111111000000000111110000000000", "000000000000001111111111111111111111111111100011111111110000000000000000000000000000000000000000011110111111111111111111111111111111111111111111111111111111111111111111111000000000111111000000000", "000000000000011111111111111111111111111111111111111111111100000000000000000000000000000000000001111011111111111111111111111111111111111111111111111111111111111111111111111000000000011111000000000", "000000000000011111111111111111111111111111011111111111111100000000000000000000000000000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111100000001111000000000", "000000000000011111111111111111111111111111111111111111111100000000000000000000000000000000001111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000111000000000", "000000000000011111111111111111111111111111111111111111111000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000011000000000", "000000000000001111111111111111111111111111111111111111000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000000000000", "000000000000011111111111111111111111111111111111111100000000000000000000000000000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000000000000", "000000000000011111111111111111111111111111111111111111000000000000000000000000000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000000000000", "000000000000111111111111111111111111111111111111111111000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000100000000000000", "000000000001111111111111111111111111111111111111111100000000000000000000000000000000011001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000110000000000000", "000000000001111111111111111111111111111111111110110000000000000000000000000000000000111111111110111111111111111111111111111111111111111111111111111111111111111111111111111111110000111000000000000", "000000000011111111111111111111111111111111111100000000000000000000000000000000000000111111111000011111111111111111111111111111111111111111111111111111111111111111111111111111000000111000000000000", "000000000111111111111111111111111111111111111000000000000000000000000000000000000000111111110000000111111111111111111111111111111111111111111111111111111111111111111111111111000000110000000000000", "000000000111111111111111111111111111111111100000000000000000000000000000000000000000111111100000000111111101111111111111111111111111111111111111111111111111111111111111011111000000110000000000000", "000000000111111111111111111111111111111111000000000000000000000000000000000000000000111111100000001110011101111111111111111111111111111111111111111111111111111111111110000111100010110000000000000", "000000000111111111111111111111111111111110000000000000000000000000000000000000000000111110011111111100011101111111111111111111111111111111111111111111111111111111111111110111110111111000000000000", "000000000111111111111111111111111111111110000000000000000000000000000000000000000000001111111111110000000000011011111111111111111111111111111111111111111111111111111111110011110111111000000000000", "000000000011111111111111111111111111111000000000000000000000000000000000000000000000011111111111100000000000000001111111111111111111111111111111111111111111111111111111110011100111110000000000000", "000000000001111111111111111111111111110000000000000000000000000000000000000000000001111111111111111000011000000001111111111111111111111111111111111111111111111111111111110000000000000000000000000", "000000000000111111111111111111111111100000000000000000000000000000000000000000000001111111111111111110011111110011111111111111111111111111111111111111111111111111111111111100000000000000000000000", "000000000001111111111111111111111111000000000000000000000000000000000000000000000001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000", "000000000000111111111111111111100111000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000", "000000000000111111111111110000000111000000000000000000000000000000000000000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000", "000000000000111111111111000000000111000000000000000000000000000000000000000000001111111111111111111111111111111110111111111101111111111111111111111111111111111111111111111100000000000000000000000", "000000000000011111111111000000000011000000000000000000000000000000000000000000011111111111111111111111111111111111111111111100011111111111111111111111111111111111111111111100000000000000000000000", "000000000000011011111111000000000000000000000000000000000000000000000000000000011111111111111111111111111111111111011111111111111000001111111111111111111111111111111111111000000000000000000000000", "000000000000000011111111000000000000000000000000000000000000000000000000000000111111111111111111111111111111111111111111111111111110000011111111111111111111111111111111110000000000000000000000000", "000000000000000011111110000111000000000000000000000000000000000000000000000000111111111111111111111111111111111111101111111111111110000001111111111111111111111111111111000000000000000000000000000", "000000000000000001111111000111000000000000000000000000000000000000000000000000111111111111111111111111111111111111111111111111111110000000111111111111000111111111100110000000000000000000000000000", "000000000000000001111111101111000000000000000000000000000000000000000000000000111111111111111111111111111111111111110111111111111100000000001111111110000111111111101110000000000000000000000000000", "000000000000000001111111111111000000000000000000000000000000000000000000000000111111111111111111111111111111111111111011111111111000000000001111111100000011111111111100000000000000000000000000000", "000000000000000000011111111111100000000000000000000000000000000000000000000000111111111111111111111111111111111111111011111111110000000000001111111000000001111111111000000000000000000000000000000", "000000000000000000000111111111110000000000000000000000000000000000000000000001111111111111111111111111111111111111111101111111100000000000001111110000000001111111111000000000000000000000000000000", "000000000000000000000000011111110000000000000000000000000000000000000000000001111111111111111111111111111111111111111111111110000000000000000111110000000000011111111100000000000000000000000000000", "000000000000000000000000000111110000000000000000000000000000000000000000000001111111111111111111111111111111111111111111111000000000000000000111110000000000011111111100000000000000000000000000000", "000000000000000000000000000001110000001111000000000000000000000000000000000001111111111111111111111111111111111111111111000011000000000000000111110000000000011111111100000000000000000000000000000", "000000000000000000000000000001110000111111111100000000000000000000000000000000011111111111111111111111111111111111111111111111000000000000000011110000000000011111111100000000000000000000000000000", "000000000000000000000000000001111001111111111110000000000000000000000000000000011111111111111111111111111111111111111111111111000000000000000011110000000000011101111000000000000000000000000000000", "000000000000000000000000000000011101111111111111100000000000000000000000000000001111111111111111111111111111111111111111111110000000000000000001100000000000001100100000000000000000000000000000000", "000000000000000000000000000000000101111111111111110000000000000000000000000000000111111111111111111111111111111111111111111110000000000000000000000000000000000000000000001100000000000000000000000", "000000000000000000000000000000000001111111111111111110000000000000000000000000000111111111111111111111111111111111111111111100000000000000000000000000000000110000000000001110000000000000000000000", "000000000000000000000000000000000001111111111111111111000000000000000000000000000001111100000111111111111111111111111111111000000000000000000000000000000000111000000000111110000000000000000000000", "000000000000000000000000000000000011111111111111111111100000000000000000000000000000000000000000111111111111111111111111111000000000000000000000000000000000011100000001111110000000000000000000000", "000000000000000000000000000000000011111111111111111111100000000000000000000000000000000000000000111111111111111111111111110000000000000000000000000000000000011110000011111110000000000000000000000", "000000000000000000000000000000000111111111111111111111100000000000000000000000000000000000000000111111111111111111111111100000000000000000000000000000000000001111000111111110000000000000000000000", "000000000000000000000000000000001111111111111111111111111000000000000000000000000000000000000001111111111111111111111111000000000000000000000000000000000000000111100111111100000000011100000000000", "000000000000000000000000000000001111111111111111111111111111000000000000000000000000000000000001111111111111111111111111000000000000000000000000000000000000000111100011111100000000011101100000000", "000000000000000000000000000000000111111111111111111111111111111000000000000000000000000000000000111111111111111111111110000000000000000000000000000000000000000011110011111000000000001111111100000", "000000000000000000000000000000001111111111111111111111111111111110000000000000000000000000000000011111111111111111111100000000000000000000000000000000000000000011110000000000000000001111111111000", "000000000000000000000000000000001111111111111111111111111111111111000000000000000000000000000000011111111111111111111000000000000000000000000000000000000000000001110000000000000000000001111111100", "000000000000000000000000000000000111111111111111111111111111111111000000000000000000000000000000001111111111111111111100000000000000000000000000000000000000000000110000000000000000000000111111100", "000000000000000000000000000000000011111111111111111111111111111111000000000000000000000000000000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000111111110", "000000000000000000000000000000000011111111111111111111111111111110000000000000000000000000000000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000011101111", "000000000000000000000000000000000001111111111111111111111111111100000000000000000000000000000000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000111", "000000000000000000000000000000000001111111111111111111111111111100000000000000000000000000000000000111111111111111111100000000000000000000000000000000000000000000000000000000000000011110001100001", "000000000000000000000000000000000001111111111111111111111111111100000000000000000000000000000000001111111111111111111100000110000000000000000000000000000000000000000000000000000000111110001100000", "000000000000000000000000000000000000111111111111111111111111111000000000000000000000000000000000001111111111111111111100001110000000000000000000000000000000000000000000000000001111111100011100000", "000000000000000000000000000000000000011111111111111111111111111000000000000000000000000000000000011111111111111111111100111110000000000000000000000000000000000000000000000000011111111110011110000", "000000000000000000000000000000000000001111111111111111111111111000000000000000000000000000000000011111111111111111111000111110000000000000000000000000000000000000000000000000111111111111111110000", "000000000000000000000000000000000000000011111111111111111111111000000000000000000000000000000000011111111111111111110000111110000000000000000000000000000000000000000000000001111111111111111110000", "000000000000000000000000000000000000000001111111111111111111111000000000000000000000000000000000001111111111111111100000111100000000000000000000000000000000000000000000000011111111111111111111000", "000000000000000000000000000000000000000001111111111111111111110000000000000000000000000000000000001111111111111111100001111100000000000000000000000000000000000000000000011111111111111111111111000", "000000000000000000000000000000000000000001111111111111111111110000000000000000000000000000000000000111111111111111100001111000000000000000000000000000000000000000000001111111111111111111111111100", "000000000000000000000000000000000000000001111111111111111111110000000000000000000000000000000000000111111111111111100001111000000000000000000000000000000000000000000001111111111111111111111111110", "000000000000000000000000000000000000000001111111111111111110000000000000000000000000000000000000000111111111111111100001111000000000000000000000000000000000000000000001111111111111111111111111110", "000000000000000000000000000000000000000001111111111111111000000000000000000000000000000000000000000111111111111111000001111000000000000000000000000000000000000000000001111111111111111111111111110", "000000000000000000000000000000000000000001111111111111111100000000000000000000000000000000000000000011111111111110000000000000000000000000000000000000000000000000000001111111111111111111111111110", "000000000000000000000000000000000000000001111111111111111000000000000000000000000000000000000000000011111111111100000000000000000000000000000000000000000000000000000011111111111111111111111111110", "000000000000000000000000000000000000000001111111111111111000000000000000000000000000000000000000000011111111111100000000000000000000000000000000000000000000000000000011111111111111111111111111110", "000000000000000000000000000000000000000001111111111111110000000000000000000000000000000000000000000001111111111000000000000000000000000000000000000000000000000000000001111111111111111111111111110", "000000000000000000000000000000000000000001111111111111110000000000000000000000000000000000000000000001111111110000000000000000000000000000000000000000000000000000000001111111111111111111111111100", "000000000000000000000000000000000000000000111111111111100000000000000000000000000000000000000000000000111111100000000000000000000000000000000000000000000000000000000011111111100011111111111111000", "000000000000000000000000000000000000000000111111111111100000000000000000000000000000000000000000000000111110000000000000000000000000000000000000000000000000000000000011111100000001111111111110000", "000000000000000000000000000000000000000000111111111110000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000011000000000000011111111100000", "000000000000000000000000000000000000000000111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111000000", "000000000000000000000000000000000000000000111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111110000000", "000000000000000000000000000000000000000000111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001111000000000", "000000000000000000000000000000000000000000111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000011111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000011111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000001111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000011111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000011111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000001111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000001111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000000111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "000000000000000000000000000000000000000000000011110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"]; const Globe = () => {
    const mountRef = useRef(null);
    const [fps, setFps] = useState(0);
    const [showDebug, setShowDebug] = useState(false);
    const isMobile = window.innerWidth < 768;

    // Refs để truy cập vào các biến Three.js từ bên ngoài (cho Debug Panel)
    const configRef = useRef({
        backgroundColor: 0x081b2e,
        globeRadius: 11,
        globeSegments: 64,
        atmosphereSize: 1.00,
        atmosphereOpacity: 0.18,
        atmosphereGlow: 1.5,
        arcColors: [0xD02C34, 0xE9A23A, 0x5494D4, 0x8A5BC8, 0xCF3250, 0x9240B3, 0xE06C33, 0x50A0D8],
        numPoints: 50000,
        dotSize: 0.05,
        dotSegments: 6,
        dotOpacity: 0.4,
        hoverEffect: 0.05,
        hoverPull: 0.45,
        maxConcurrentArcs: 10,
        arcFrequency: 0.4,
        arcTimingVariation: 0.15,
        arcTubeSegments: 18,
        arcRadialSegments: 6,
        arcThickness: 0.038,
        arcPointsCount: 80,
        rotationSpeed: 0.002,
        arcGrowDuration: 1.3,
        arcRetreatDuration: 2.8,
        impactSize: 0.05,
        bullseyeSize: 0.10,
        bullseyeRingSize: 0.2,
        useHighPerformanceMode: false,
        skipFrames: 0
    });

    // State refs cho logic animation
    const sceneRef = useRef(null);
    const globeGroupRef = useRef(null);
    const rendererRef = useRef(null);
    const cameraRef = useRef(null);
    const landPointsRef = useRef([]);
    const landDotsRef = useRef(null);
    const arcsRef = useRef([]);
    const arcsGroupRef = useRef(null);
    const impactEffectsRef = useRef([]);
    let isTouching = false;

    // Ref chứa các hàm update để UI gọi
    const apiRef = useRef({});

    useEffect(() => {
        const CONFIG = configRef.current;
        //     if (isMobile) {
        //   CONFIG.globeRadius = 8.5;
        //   CONFIG.numPoints = Math.min(CONFIG.numPoints, 15000);
        //   CONFIG.arcThickness *= 0.75;
        // }
        if (isMobile) {
            CONFIG.globeRadius = 9.8;
            CONFIG.numPoints = Math.min(CONFIG.numPoints, 18000);
            CONFIG.arcThickness *= 0.85;
        }


        // --- 1. Setup Three.js ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(CONFIG.backgroundColor);
        sceneRef.current = scene;

        // const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        // camera.position.z = 25;
        // camera.position.y = 10;
        // camera.lookAt(0, 0, 0);
        const camera = new THREE.PerspectiveCamera(
            isMobile ? 65 : 75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );

        // camera.position.z = isMobile ? 32 : 25;
        // camera.position.y = isMobile ? 6 : 10;
        camera.position.z = isMobile ? 30 : 25;
        camera.position.y = 0;
        camera.lookAt(0, 0, 0);

        cameraRef.current = camera;

        // const renderer = new THREE.WebGLRenderer({
        //   antialias: !CONFIG.useHighPerformanceMode,
        //   powerPreference: "high-performance",
        //   precision: "mediump"
        // });
        const renderer = new THREE.WebGLRenderer({
            antialias: false,
            powerPreference: "default",
            precision: "mediump",
            failIfMajorPerformanceCaveat: false,
            alpha: true
        });
        renderer.sortObjects = false;
        // renderer.setSize(window.innerWidth, window.innerHeight);
        const { clientWidth, clientHeight } = mountRef.current;

        renderer.setSize(clientWidth, clientHeight);
        camera.aspect = clientWidth / clientHeight;
        camera.updateProjectionMatrix();

        const pixelRatio = CONFIG.useHighPerformanceMode ? 1 : (window.devicePixelRatio > 2 ? 1.5 : window.devicePixelRatio);
        renderer.setPixelRatio(pixelRatio);
        renderer.shadowMap.enabled = false;
        mountRef.current.appendChild(renderer.domElement);
        rendererRef.current = renderer;

        const globeGroup = new THREE.Group();
        scene.add(globeGroup);
        globeGroupRef.current = globeGroup;

        // --- 2. Globe Construction ---
        // Blue globe
        const globeGeometry = new THREE.SphereGeometry(CONFIG.globeRadius, CONFIG.globeSegments, CONFIG.globeSegments);
        const globeMaterial = new THREE.MeshPhongMaterial({
            color: 0x005280,
            shininess: 15,
            specular: 0x223344,
            emissive: 0x002a56,
            transparent: true,
            opacity: 0.94
        });
        const globe = new THREE.Mesh(globeGeometry, globeMaterial);
        globeGroup.add(globe);

        // Inner Glow
        const innerGlowGeometry = new THREE.SphereGeometry(CONFIG.globeRadius * 1.01, CONFIG.globeSegments, CONFIG.globeSegments);
        const innerGlowMaterial = new THREE.MeshBasicMaterial({
            color: 0x003466,
            transparent: true,
            opacity: 0.13,
            side: THREE.BackSide
        });
        const innerGlow = new THREE.Mesh(innerGlowGeometry, innerGlowMaterial);
        globeGroup.add(innerGlow);

        // Atmosphere Shader
        const atmosphereSize = CONFIG.globeRadius * CONFIG.atmosphereSize * 1.05;
        const atmosphereGeometry = new THREE.SphereGeometry(atmosphereSize, CONFIG.globeSegments, CONFIG.globeSegments);
        const atmosphereMaterial = new THREE.ShaderMaterial({
            uniforms: {
                globeRadius: { value: CONFIG.globeRadius },
                atmosphereRadius: { value: atmosphereSize },
                color: { value: new THREE.Color(0x4499ff) },
                glowColor: { value: new THREE.Color(0x99bbff) },
                opacity: { value: CONFIG.atmosphereOpacity * 1.5 },
                power: { value: 2.0 },
                time: { value: 0.0 }
            },
            vertexShader: `
        varying vec3 vPosition;
        varying vec3 vNormal;
        varying vec3 vWorldPosition;
        void main() {
          vNormal = normalize(normalMatrix * normal);
          vPosition = position;
          vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
            fragmentShader: `
        uniform float globeRadius;
        uniform float atmosphereRadius;
        uniform vec3 color;
        uniform vec3 glowColor;
        uniform float opacity;
        uniform float power;
        uniform float time;
        varying vec3 vNormal;
        varying vec3 vWorldPosition;
        void main() {
          float intensity = pow(0.75 - dot(vNormal, vec3(0, 0, 1.0)), power);
          float pulse = 1.0 + 0.15 * sin(time * 0.5);
          float secondaryPulse = 1.0 + 0.08 * sin(time * 0.8 + 1.5);
          float positionEffect = sin(vWorldPosition.x * 0.2 + time * 0.3) * cos(vWorldPosition.y * 0.2 + time * 0.2) * sin(vWorldPosition.z * 0.2 + time * 0.4);
          intensity *= 1.0 + 0.2 * positionEffect;
          vec3 finalColor = mix(color, glowColor, intensity) * pulse * secondaryPulse;
          finalColor.r += 0.1 * sin(vWorldPosition.y * 0.1 + time * 0.2);
          finalColor.g += 0.05 * cos(vWorldPosition.z * 0.1 + time * 0.3);
          finalColor.b += 0.15 * sin(vWorldPosition.x * 0.1 + time * 0.4);
          gl_FragColor = vec4(finalColor, min(1.0, opacity * intensity * 2.0 * pulse));
        }
      `,
            side: THREE.BackSide,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
        globeGroup.add(atmosphere);

        // Lights
        const ambientLight = new THREE.AmbientLight(0x333344, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
        directionalLight.position.set(8, 8, 8);
        scene.add(directionalLight);
        const backLight = new THREE.PointLight(0x0077ff, 4.5, 75);
        backLight.position.set(-20, 8, -20);
        scene.add(backLight);
        const rimLight = new THREE.PointLight(0x0044ff, 1.8, 55);
        rimLight.position.set(-5, -15, -10);
        scene.add(rimLight);
        const fillLight = new THREE.DirectionalLight(0xffffff, 0.25);
        fillLight.position.set(0, 15, 15);
        scene.add(fillLight);

        const atmosphereLight = new THREE.PointLight(0x5599ff, CONFIG.atmosphereGlow * 1.5, atmosphereSize * 4);
        globeGroup.add(atmosphereLight);
        const atmosphereLight2 = new THREE.PointLight(0x3377ff, CONFIG.atmosphereGlow * 0.8, atmosphereSize * 3.5);
        atmosphereLight2.position.set(CONFIG.globeRadius * 0.2, -CONFIG.globeRadius * 0.1, CONFIG.globeRadius * 0.1);
        globeGroup.add(atmosphereLight2);

        // --- 3. Land Points Logic ---
        const landDotsGroup = new THREE.Group();
        globeGroup.add(landDotsGroup);
        landDotsRef.current = landDotsGroup;

        const createLandPoints = () => {
            // Cleanup existing
            while (landDotsGroup.children.length > 0) {
                const child = landDotsGroup.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
                landDotsGroup.remove(child);
            }
            landPointsRef.current = [];

            const dotGeometry = new THREE.CircleGeometry(CONFIG.dotSize, CONFIG.dotSegments);
            const dotMaterial = new THREE.MeshBasicMaterial({
                color: 0xbbeeff,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: CONFIG.dotOpacity,
                depthTest: true,
                depthWrite: true,
                blending: THREE.NormalBlending
            });

            const landPositions = [];
            const landNormals = [];
            const numPoints = CONFIG.numPoints;
            const radius = CONFIG.globeRadius;

            // Helper to check land using worldMap bitmap
            const isLand = (lat, lon) => {
                const latIndex = Math.min(worldMap.length - 1, Math.max(0, Math.floor((90 - lat) * worldMap.length / 180)));
                const lonIndex = Math.min(worldMap[0].length - 1, Math.max(0, Math.floor((lon + 180) * worldMap[0].length / 360)));
                return worldMap[latIndex][lonIndex] === '1';
            };

            for (let i = 0; i < numPoints; i++) {
                const phi = Math.acos(1 - 2 * (i + 0.5) / numPoints);
                const theta = Math.PI * (1 + Math.sqrt(5)) * (i + 0.5);
                const lat = 90 - (phi * 180 / Math.PI);
                const lon = (theta * 180 / Math.PI) % 360 - 180;

                if (isLand(lat, lon)) {
                    const phiRad = (90 - lat) * Math.PI / 180;
                    const thetaRad = (lon + 180) * Math.PI / 180;
                    const pointRadius = radius * 1.005;
                    const x = -pointRadius * Math.sin(phiRad) * Math.cos(thetaRad);
                    const y = pointRadius * Math.cos(phiRad);
                    const z = pointRadius * Math.sin(phiRad) * Math.sin(thetaRad);

                    landPositions.push(x, y, z);
                    const normal = new THREE.Vector3(x, y, z).normalize();
                    landNormals.push(normal.x, normal.y, normal.z);
                }
            }

            const instanceCount = landPositions.length / 3;
            if (instanceCount > 0) {
                const instancedDots = new THREE.InstancedMesh(dotGeometry, dotMaterial, instanceCount);
                const matrix = new THREE.Matrix4();
                const quaternion = new THREE.Quaternion();
                const position = new THREE.Vector3();
                const scale = new THREE.Vector3(1, 1, 1);
                const up = new THREE.Vector3(0, 1, 0);

                for (let i = 0; i < instanceCount; i++) {
                    position.set(landPositions[i * 3], landPositions[i * 3 + 1], landPositions[i * 3 + 2]);
                    const normal = new THREE.Vector3(landNormals[i * 3], landNormals[i * 3 + 1], landNormals[i * 3 + 2]);
                    const lookAt = position.clone().add(normal);
                    const rotationMatrix = new THREE.Matrix4().lookAt(position, lookAt, up);
                    quaternion.setFromRotationMatrix(rotationMatrix);
                    matrix.compose(position, quaternion, scale);
                    instancedDots.setMatrixAt(i, matrix);

                    landPointsRef.current.push({
                        index: i,
                        position: position.clone(),
                        originalPosition: position.clone()
                    });
                }
                instancedDots.instanceMatrix.needsUpdate = true;
                landDotsGroup.add(instancedDots);
                landDotsGroup.userData.instancedDots = instancedDots;
            }
        };

        createLandPoints();

        // --- 4. Arcs Logic ---
        const arcsGroup = new THREE.Group();
        globeGroup.add(arcsGroup);
        arcsGroupRef.current = arcsGroup;
        arcsRef.current = [];
        const onTouchStart = (e) => {
            isTouching = true;
            const touch = e.touches[0];
            previousMousePosition = { x: touch.clientX, y: touch.clientY };
        };

        const onTouchMove = (e) => {

            if (!isTouching) return;
            const touch = e.touches[0];

            const deltaX = touch.clientX - previousMousePosition.x;
            const deltaY = touch.clientY - previousMousePosition.y;

            globeRotation.y += deltaX * 0.008;
            globeRotation.x += deltaY * 0.008;
            globeRotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, globeRotation.x));

            globeGroup.rotation.y = globeRotation.y;
            globeGroup.rotation.x = globeRotation.x;

            previousMousePosition = { x: touch.clientX, y: touch.clientY };
        };

        const onTouchEnd = () => {
            isTouching = false;
        };

        const createArc = (startPoint, endPoint) => {
            const startPos = startPoint.position.clone();
            const endPos = endPoint.position.clone();
            const midPoint = startPos.clone().add(endPos).multiplyScalar(0.5);
            const distance = startPos.distanceTo(endPos);

            midPoint.normalize().multiplyScalar(CONFIG.globeRadius + distance * 1.8);
            const adjustStartPos = startPos.clone().normalize().multiplyScalar(CONFIG.globeRadius * 0.997);
            const adjustEndPos = endPos.clone().normalize().multiplyScalar(CONFIG.globeRadius * 0.997);

            const allPoints = [];
            for (let i = 0; i <= CONFIG.arcPointsCount; i++) {
                let t;
                if (i === 0) t = 0;
                else if (i === CONFIG.arcPointsCount) t = 1;
                else {
                    const normalizedI = i / CONFIG.arcPointsCount;
                    t = (Math.sin((normalizedI - 0.5) * Math.PI) + 1) / 2;
                }

                const point = new THREE.Vector3();
                if (i === 0) point.copy(adjustStartPos);
                else if (i === CONFIG.arcPointsCount) point.copy(adjustEndPos);
                else {
                    const cp1 = new THREE.Vector3().lerpVectors(adjustStartPos, midPoint, 0.25);
                    const cp2 = new THREE.Vector3().lerpVectors(midPoint, adjustEndPos, 0.75);
                    const u = 1 - t;
                    const tt = t * t;
                    const uu = u * u;
                    const uuu = uu * u;
                    const ttt = tt * t;
                    point.x = uuu * adjustStartPos.x + 3 * uu * t * cp1.x + 3 * u * tt * cp2.x + ttt * adjustEndPos.x;
                    point.y = uuu * adjustStartPos.y + 3 * uu * t * cp1.y + 3 * u * tt * cp2.y + ttt * adjustEndPos.y;
                    point.z = uuu * adjustStartPos.z + 3 * uu * t * cp1.z + 3 * u * tt * cp2.z + ttt * adjustEndPos.z;
                }
                allPoints.push(point);
            }

            const tubePath = new THREE.CatmullRomCurve3([allPoints[0], allPoints[1], allPoints[2], allPoints[3]]);
            tubePath.tension = 0.5;
            const tubeGeometry = new THREE.TubeGeometry(tubePath, 3, CONFIG.arcThickness, CONFIG.arcRadialSegments, false);

            // Gradient Texture
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 1;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createLinearGradient(0, 0, 256, 0);

            const color1 = new THREE.Color(CONFIG.arcColors[Math.floor(Math.random() * CONFIG.arcColors.length)]);
            let color2 = new THREE.Color(CONFIG.arcColors[Math.floor(Math.random() * CONFIG.arcColors.length)]);

            gradient.addColorStop(0, '#' + color1.getHexString());
            gradient.addColorStop(1, '#' + color2.getHexString());
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 256, 1);

            const gradientTexture = new THREE.CanvasTexture(canvas);
            const tubeMaterial = new THREE.MeshBasicMaterial({
                opacity: 0.9, transparent: true, depthWrite: false, blending: THREE.AdditiveBlending, map: gradientTexture
            });

            const arcMesh = new THREE.Mesh(tubeGeometry, tubeMaterial);
            globeGroup.add(arcMesh);

            return {
                arc: arcMesh, tubeMaterial, allPoints, age: 0,
                growDuration: CONFIG.arcGrowDuration + Math.random() * 0.4,
                maxLife: CONFIG.arcRetreatDuration + Math.random() * 0.8,
                destinationPoint: endPos.clone(),
                impactCreated: false, endColor: color2
            };
        };

        const createImpactEffect = (position, color) => {
            const impactColor = color || new THREE.Color(0x88eeff);

            // Rings
            const ringGeo = new THREE.RingGeometry(CONFIG.bullseyeSize * 0.67, CONFIG.bullseyeSize, 24);
            const ringMat = new THREE.MeshBasicMaterial({ color: impactColor, side: THREE.DoubleSide, transparent: true, opacity: 0.95, depthWrite: false, blending: THREE.AdditiveBlending });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.position.copy(position);
            ring.lookAt(new THREE.Vector3(0, 0, 0));
            globeGroup.add(ring);

            // Center Bullseye
            const dotGeo = new THREE.CircleGeometry(CONFIG.bullseyeSize, 24);
            const dotMat = new THREE.MeshBasicMaterial({ color: impactColor, side: THREE.DoubleSide, transparent: true, opacity: 0.85, depthWrite: false, blending: THREE.AdditiveBlending });
            const dot = new THREE.Mesh(dotGeo, dotMat);
            dot.position.copy(position).add(position.clone().normalize().multiplyScalar(0.008));
            dot.lookAt(new THREE.Vector3(0, 0, 0));
            globeGroup.add(dot);

            return {
                circle: ring, circleMaterial: ringMat, centerDot: dot, centerDotMaterial: dotMat,
                age: 0, maxLife: 0.5 + Math.random() * 0.3, isFadingOut: false
            };
        };

        const addRandomArc = () => {
            if (landPointsRef.current.length < 2) return;
            const startIndex = Math.floor(Math.random() * landPointsRef.current.length);
            const startPoint = landPointsRef.current[startIndex];

            // Tìm endpoint ngẫu nhiên
            let endPointIndex = -1;
            let attempts = 0;
            while (endPointIndex === -1 && attempts < 20) {
                const idx = Math.floor(Math.random() * landPointsRef.current.length);
                if (idx !== startIndex) {
                    const dist = startPoint.position.distanceTo(landPointsRef.current[idx].position);
                    if (dist > CONFIG.globeRadius * 0.25 && dist < CONFIG.globeRadius * 1.6) {
                        endPointIndex = idx;
                    }
                }
                attempts++;
            }

            if (endPointIndex !== -1) {
                const arc = createArc(startPoint, landPointsRef.current[endPointIndex]);
                arcsRef.current.push(arc);
            }
        };

        // --- 5. Interaction (Rotation & Hover) ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let globeRotation = { x: 0, y: 0 };

        const onMouseDown = (e) => {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
            document.body.style.cursor = 'grabbing';
        };
        const onMouseUp = () => {
            isDragging = false;
            document.body.style.cursor = 'auto';
        };
        const onMouseMove = (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            if (isDragging) {
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;
                globeRotation.y += deltaX * 0.01;
                globeRotation.x += deltaY * 0.01;
                globeRotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, globeRotation.x));
                globeGroup.rotation.y = globeRotation.y;
                globeGroup.rotation.x = globeRotation.x;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            }
        };

        window.addEventListener('mousedown', onMouseDown);
        window.addEventListener('mouseup', onMouseUp);
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('touchstart', onTouchStart, { passive: false });
        window.addEventListener('touchmove', onTouchMove, { passive: false });
        window.addEventListener('touchend', onTouchEnd);

        // --- 6. Animation Loop ---
        let lastArcTime = 0;
        let lastFrameTime = 0;

        const animate = (time) => {
            const reqId = requestAnimationFrame(animate);
            const seconds = time / 1000;

            // FPS Calc
            if (time - lastFrameTime >= 100) { // Update FPS every 100ms
                setFps(Math.round(1000 / (time - lastFrameTime)));
                lastFrameTime = time;
            }

            // Auto Rotation
            if (!isDragging) {
                globeRotation.y += CONFIG.rotationSpeed;
                globeGroup.rotation.y = globeRotation.y;
            }

            // Atmosphere Animation
            if (atmosphere.material.uniforms) {
                atmosphere.material.uniforms.time.value = seconds;
                atmosphere.material.uniforms.viewVector = new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z);
            }

            // Arc Generation
            if (seconds - lastArcTime > CONFIG.arcFrequency || (arcsRef.current.length < CONFIG.maxConcurrentArcs * 0.7 && seconds - lastArcTime > 0.1)) {
                addRandomArc();
                lastArcTime = seconds;
            }

            // Update Arcs
            for (let i = arcsRef.current.length - 1; i >= 0; i--) {
                const arc = arcsRef.current[i];
                arc.age += 0.02;

                if (arc.age < arc.growDuration) {
                    // Growing
                    let progress = arc.age / arc.growDuration;
                    if (progress >= 0.9 && !arc.impactCreated) {
                        const effect = createImpactEffect(arc.destinationPoint, arc.endColor);
                        impactEffectsRef.current.push(effect);
                        arc.impactCreated = true;
                        arc.impactEffect = effect;
                    }

                    // Update Geometry
                    const pointCount = Math.max(2, Math.floor(progress * arc.allPoints.length));
                    const currentPoints = arc.allPoints.slice(0, pointCount);

                    try {
                        const tubePath = new THREE.CatmullRomCurve3(currentPoints);
                        tubePath.tension = 0.4;
                        const geo = new THREE.TubeGeometry(tubePath, Math.max(5, Math.ceil(pointCount * 0.8)), CONFIG.arcThickness, CONFIG.arcRadialSegments, false);
                        arc.arc.geometry.dispose();
                        arc.arc.geometry = geo;
                    } catch (e) { }

                } else if (arc.age > arc.growDuration) {
                    // Retreating
                    let retreatProgress = (arc.age - arc.growDuration) / arc.maxLife;
                    const startIndex = Math.floor(retreatProgress * arc.allPoints.length);
                    const pointCount = arc.allPoints.length - startIndex;

                    if (pointCount < 2) {
                        arc.tubeMaterial.opacity = 0;
                        continue;
                    }

                    try {
                        const currentPoints = arc.allPoints.slice(startIndex);
                        const tubePath = new THREE.CatmullRomCurve3(currentPoints);
                        tubePath.tension = 0.4;
                        const geo = new THREE.TubeGeometry(tubePath, Math.max(5, Math.ceil(pointCount * 0.9)), CONFIG.arcThickness * (1 - retreatProgress * 0.3), CONFIG.arcRadialSegments, false);
                        arc.arc.geometry.dispose();
                        arc.arc.geometry = geo;
                    } catch (e) { }
                }

                if (arc.age >= arc.growDuration + arc.maxLife) {
                    globeGroup.remove(arc.arc);
                    arc.arc.geometry.dispose();
                    arc.tubeMaterial.dispose();
                    if (arc.impactEffect) arc.impactEffect.isFadingOut = true;
                    arcsRef.current.splice(i, 1);
                }
            }

            // Update Impacts
            for (let i = impactEffectsRef.current.length - 1; i >= 0; i--) {
                const effect = impactEffectsRef.current[i];
                effect.age += 0.02;

                if (effect.isFadingOut || effect.age > effect.maxLife) {
                    effect.circleMaterial.opacity *= 0.9;
                    effect.centerDotMaterial.opacity *= 0.9;
                    if (effect.circleMaterial.opacity < 0.01) {
                        globeGroup.remove(effect.circle);
                        globeGroup.remove(effect.centerDot);
                        effect.circle.geometry.dispose(); effect.circleMaterial.dispose();
                        effect.centerDot.geometry.dispose(); effect.centerDotMaterial.dispose();
                        impactEffectsRef.current.splice(i, 1);
                    }
                } else {
                    const progress = effect.age / effect.maxLife;
                    const innerRadius = (0.15 + progress * CONFIG.globeRadius * CONFIG.impactSize);
                    effect.circle.geometry.dispose();
                    effect.circle.geometry = new THREE.RingGeometry(innerRadius * 0.8, innerRadius, 24);
                    effect.circleMaterial.opacity = Math.max(0, 0.8 * (1 - progress));
                }
            }

            // Hover Effect
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(globe);
            if (intersects.length > 0 && landDotsGroup.userData.instancedDots) {
                const intersectionPoint = intersects[0].point.clone();
                globeGroup.worldToLocal(intersectionPoint);

                const instancedDots = landDotsGroup.userData.instancedDots;
                const matrix = new THREE.Matrix4();
                const quaternion = new THREE.Quaternion();
                const pos = new THREE.Vector3();
                const scale = new THREE.Vector3(1, 1, 1);
                const up = new THREE.Vector3(0, 1, 0);

                for (let i = 0; i < landPointsRef.current.length; i++) {
                    const dot = landPointsRef.current[i];
                    const dist = dot.originalPosition.distanceTo(intersectionPoint);
                    const maxDist = CONFIG.globeRadius * CONFIG.hoverPull;

                    if (dist < maxDist) {
                        const factor = Math.pow(Math.cos(dist / maxDist * Math.PI * 0.5), 4) * CONFIG.hoverEffect * 1.5;
                        const newPos = dot.originalPosition.clone().add(dot.originalPosition.clone().normalize().multiplyScalar(CONFIG.globeRadius * factor));

                        pos.copy(newPos);
                        const lookAt = pos.clone().add(pos.clone().normalize());
                        quaternion.setFromRotationMatrix(new THREE.Matrix4().lookAt(pos, lookAt, up));
                        matrix.compose(pos, quaternion, scale);
                        instancedDots.setMatrixAt(dot.index, matrix);
                    } else {
                        // Reset (Optimization: only needed if previously moved, but doing all for safety)
                        pos.copy(dot.originalPosition);
                        const lookAt = pos.clone().add(pos.clone().normalize());
                        quaternion.setFromRotationMatrix(new THREE.Matrix4().lookAt(pos, lookAt, up));
                        matrix.compose(pos, quaternion, scale);
                        instancedDots.setMatrixAt(dot.index, matrix);
                    }
                }
                instancedDots.instanceMatrix.needsUpdate = true;
            }

            renderer.render(scene, camera);
            return reqId; // For cleanup
        };

        const animationId = animate(performance.now());

        // Resize Handler
        // const onResize = () => {
        //     camera.aspect = window.innerWidth / window.innerHeight;
        //     camera.updateProjectionMatrix();
        //     renderer.setSize(window.innerWidth, window.innerHeight);
        // };
        const onResize = () => {
            if (!mountRef.current) return;

            const { clientWidth, clientHeight } = mountRef.current;
            camera.aspect = clientWidth / clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(clientWidth, clientHeight);
        };

        window.addEventListener('resize', onResize);

        // --- Expose update functions ---
        apiRef.current = {
            updateGlobe: () => {
                globe.geometry.dispose();
                globe.geometry = new THREE.SphereGeometry(configRef.current.globeRadius, configRef.current.globeSegments, configRef.current.globeSegments);
                createLandPoints(); // Need to regenerate points if radius changes
            },
            updateAtmosphere: () => {
                atmosphere.material.uniforms.opacity.value = configRef.current.atmosphereOpacity * 1.5;
            },
            regenerateDots: createLandPoints
        };

        // Cleanup
        return () => {
            cancelAnimationFrame(animationId);
            window.removeEventListener('mousedown', onMouseDown);
            window.removeEventListener('mouseup', onMouseUp);
            window.removeEventListener('mousemove', onMouseMove);
            window.removeEventListener('resize', onResize);
            window.removeEventListener('touchstart', onTouchStart);
            window.removeEventListener('touchmove', onTouchMove);
            window.removeEventListener('touchend', onTouchEnd);

            if (mountRef.current && renderer.domElement) {
                mountRef.current.removeChild(renderer.domElement);
            }
            // Dispose Three.js resources...
            renderer.dispose();
        };

    }, []); // Run once on mount

    // UI Handlers
    const handleConfigChange = (key, value, type = 'float') => {
        const parsedVal = type === 'int' ? parseInt(value) : (type === 'bool' ? value : parseFloat(value));
        configRef.current[key] = parsedVal;

        // Trigger updates based on key
        if (key === 'globeRadius' || key === 'globeSegments') apiRef.current.updateGlobe();
        if (key === 'atmosphereOpacity') apiRef.current.updateAtmosphere();
        if (key === 'numPoints' || key === 'dotSize') apiRef.current.regenerateDots();
    };

    return (
        <div className="globe-container">
            {/* <div id="fps-counter" className="fps-counter">FPS: {fps}</div>
      <button className="debug-toggle" onClick={() => setShowDebug(!showDebug)}>Control Panel</button>
       */}
            {showDebug && (
                <div className="debug-panel">
                    <h3>Configuration Controls</h3>

                    <div className="control-group">
                        <h4>Globe Appearance</h4>
                        <div className="control-item">
                            <label>Globe Radius</label>
                            <input type="range" min="8" max="15" step="0.5" defaultValue={configRef.current.globeRadius} onChange={(e) => handleConfigChange('globeRadius', e.target.value)} />
                        </div>
                        <div className="control-item">
                            <label>Atmosphere Opacity</label>
                            <input type="range" min="0.05" max="0.5" step="0.01" defaultValue={configRef.current.atmosphereOpacity} onChange={(e) => handleConfigChange('atmosphereOpacity', e.target.value)} />
                        </div>
                    </div>

                    <div className="control-group">
                        <h4>Land Points</h4>
                        <div className="control-item">
                            <label>Points Count</label>
                            <input type="range" min="3000" max="50000" step="1000" defaultValue={configRef.current.numPoints} onChange={(e) => handleConfigChange('numPoints', e.target.value, 'int')} />
                        </div>
                        <div className="control-item">
                            <label>Dot Size</label>
                            <input type="range" min="0.01" max="0.2" step="0.01" defaultValue={configRef.current.dotSize} onChange={(e) => handleConfigChange('dotSize', e.target.value)} />
                        </div>
                    </div>

                    <div className="control-group">
                        <h4>Animation</h4>
                        <div className="control-item">
                            <label>Rotation Speed</label>
                            <input type="range" min="0" max="0.01" step="0.0005" defaultValue={configRef.current.rotationSpeed} onChange={(e) => handleConfigChange('rotationSpeed', e.target.value)} />
                        </div>
                    </div>
                </div>
            )}

            <div ref={mountRef} className="globe-canvas" />
        </div>
    );
};

export default Globe;